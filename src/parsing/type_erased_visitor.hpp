#ifndef APIMU_PARSING_TYPE_ERASED_VISITOR_HPP
#define APIMU_PARSING_TYPE_ERASED_VISITOR_HPP

#include <any>
#include <functional>
#include <span>
#include "parser.hpp"

namespace apimu::parsing {
#include "macros_open.hpp"

  // Experimental.
  // Uses simple disambiguation strategy (prefer largest rule ID of child node).
  template <typename Context>
  class TypeErasedVisitor {
  public:
    template <typename T>
    class View;

    // Type-erased subtree handle.
    class Handle {
    public:
      Handle(EarleyParser& parser, bool leaf, size_t index, TypeErasedVisitor const& visitor, Context& context):
        _parser(parser),
        _leaf(leaf),
        _index(index),
        _visitor(visitor),
        _context(context),
        _payload() {}

      // Converts token positions to character positions.
      auto convert(size_t begin, size_t end) const -> std::pair<size_t, size_t> {
        auto const& tokens = _parser.tokens();
        assert(begin <= end && end <= tokens.size());
        auto const b = begin < tokens.size() ? tokens[begin].begin : tokens.back().end;
        auto const e =
          end < tokens.size() ? (end > begin ? tokens[end - 1].end : tokens[end].begin) : tokens.back().end;
        return {b, e};
      }

      // Visits parse forest node.
      auto visit() -> void {
        if (_leaf) {
          // Find corresponding token.
          auto const& tokens = _parser.tokens();
          auto const& t = tokens[_index];
          // Invoke handler function.
          _visitor._patternHandlers[t.id.value()](*this, t.lexeme);
        } else {
          // Disambiguate and collect handles to children.
          auto const& nodes = _parser.nodes();
          auto const& rules = _parser.grammar().rules;
          auto curr = _parser.propagate({_index});
          auto cs = std::vector<std::pair<bool, size_t>>();
          while (!nodes[curr].next.empty()) {
            assert(!_visitor._unambiguous || nodes[curr].next.size() == 1);
            auto max = nodes[curr].next[0];
            for (auto const i: nodes[curr].next)
              if (nodes[i.child].state.rule > nodes[max.child].state.rule) max = i;
            cs.emplace_back(max.leaf, max.child);
            curr = max.sibling;
          }
          assert(curr == _index);
          assert(cs.size() == rules[nodes[_index].state.rule].rhs.size());
          _parser.unpropagate({_index});
          auto hs = std::vector<Handle>();
          for (auto const& [cleaf, cindex]: cs) hs.emplace_back(_parser, cleaf, cindex, _visitor, _context);
          // Invoke handler function.
          _visitor._ruleHandlers[nodes[_index].state.rule](*this, hs);
        }
        // Handler function must "return" a value using `View::operator<<()`.
        assert(_payload.has_value());
      }

    private:
      EarleyParser& _parser;
      bool _leaf;
      size_t _index;
      TypeErasedVisitor const& _visitor;
      Context& _context;
      std::any _payload;

      template <typename T>
      friend class View;
    };

    // Typed interface for subtree handle.
    template <typename T>
    class View {
    public:
      View(Handle& handle):
        _handle(handle) {}

      // Visits node with a different visitor.
      template <typename U>
      auto visit(TypeErasedVisitor const& visitor) const -> U {
        auto handle = Handle(_handle.parser, _handle._leaf, _handle._index, visitor, _handle._context);
        handle.visit();
        return std::any_cast<U&&>(std::move(handle._payload));
      }

      // Visits node and returns result.
      auto operator*() const -> T {
        _handle.visit();
        return std::any_cast<T&&>(std::move(_handle._payload));
      }

      // Returns the source location of node.
      auto operator&() const -> std::pair<size_t, size_t> {
        if (_handle._leaf) {
          auto const& t = _handle._parser.tokens()[_handle._index];
          return {t.begin, t.end};
        } else {
          auto const& t = _handle._parser.nodes()[_handle._index].state;
          return _handle.convert(t.begin, t.end);
        }
      }

      // Accesses the context.
      auto operator!() const -> Context& { return _handle._context; }

      // Assigns value to node.
      auto operator<<(T value) const -> void { _handle._payload = std::move(value); }

    private:
      Handle& _handle;
    };

    // Construction simply takes arrays of `std::function`s, which may be generated by a `TypeMappedBuilder`.
    TypeErasedVisitor(
      bool unambiguous,
      std::vector<std::function<void(Handle&, std::string_view)>> patternHandlers,
      std::vector<std::function<void(Handle&, std::span<Handle>)>> ruleHandlers
    ):
      _unambiguous(unambiguous),
      _patternHandlers(std::move(patternHandlers)),
      _ruleHandlers(std::move(ruleHandlers)) {}

    // Visits parse result.
    template <typename T>
    auto visit(EarleyParser& parser, Context& context) const -> T {
      assert(_patternHandlers.size() == parser.grammar().numSymbols);
      assert(_ruleHandlers.size() == parser.grammar().rules.size());
      auto const& nodes = parser.nodes();
      auto const& result = parser.finalStates();
      assert(!result.empty());
      assert(!_unambiguous || result.size() == 1);
      auto max = result[0];
      for (auto const i: result)
        if (nodes[i].state.rule > nodes[max].state.rule) max = i;
      // Given type `T` must match the root symbol.
      auto handle = Handle(parser, false, max, *this, context);
      return *View<T>(handle);
    }

  private:
    bool _unambiguous;
    std::vector<std::function<void(Handle&, std::string_view)>> _patternHandlers;
    std::vector<std::function<void(Handle&, std::span<Handle>)>> _ruleHandlers;
  };

#include "macros_close.hpp"
}

#endif // APIMU_PARSING_TYPE_ERASED_VISITOR_HPP
