// Parsing :: CFG, Parser

#ifndef PARSER_HPP_
#define PARSER_HPP_

#include <deque>
#include <limits>
#include <optional>
#include <unordered_map>
#include <utility>
#include <variant>
#include <vector>
#include <common.hpp>
#include "generator.hpp"
#include "lexer.hpp"

namespace Parsing {

  // Preprocessed context-free grammar for use by `Parser`.
  // TODO: make a builder class.
  class CFG {
  public:
    struct Rule {
      std::pair<Symbol, Precedence> lhs;
      std::vector<std::pair<Symbol, Precedence>> rhs;
    };

    std::vector<Rule> rules;  // Rule ID -> (LHS symbol, RHS symbols).
    Symbol startSymbol = 0;   // Starting symbol ID.
    Symbol ignoredSymbol = 0; // Ignored symbol ID.

    // Processed results.
    Symbol numSymbols = 0;                        // (Maximum symbol ID occured in rules) + 1.
    std::vector<std::optional<size_t>> emptyRule; // LHS symbol ID -> empty rule ID.
    std::vector<size_t> sorted;                   // Indices of non-empty rules, sorted by LHS symbol ID.
    std::vector<size_t> firstRule;                // LHS symbol ID -> index in `mSorted`.

    auto clear() -> void {
      rules.clear();
      startSymbol = 0;
      ignoredSymbol = 0;
    }

    // Processes grammar.
    auto process() -> void;
  };

  // Earley items.
  struct State {
    size_t startPos;
    size_t endPos;
    size_t rule;
    size_t progress;

    // Equality operator and hasher class are required since `State`s are used as keys to `std::unordered_map`.
    auto operator==(State const&) const -> bool = default;

    // Equality operator and hasher class are required since `State`s are used as keys to `std::unordered_map`.
    struct Hasher {
      auto operator()(State const& s) const -> size_t {
        return hash_combine(hash_combine(hash_combine(s.startPos, s.endPos), s.rule), s.progress);
      }
    };
  };

  // Earley items with links.
  struct Node {
    struct Link {
      Node const* prev;
      std::variant<Node const*, Token const*> child;
    };
    State const state;
    std::vector<Link> links;
  };

  // Error generated by parser.
  struct ParserError {
    size_t startPos;
    size_t endPos;
    std::vector<Symbol> expected;
    std::optional<Symbol> got;
  };

  class EarleyParser {
  public:
    explicit EarleyParser(CFG const* grammar, Generator<std::optional<Token>>* generator):
      _grammar(grammar),
      _generator(generator) {}

    auto eof() const -> bool { return _generator->eof(); }
    auto advance() -> bool;

    // Retrieves results.
    auto sentence() const -> std::deque<Token> const& { return _sentence; }
    auto forest() const -> std::deque<std::deque<Node>> const& { return _forest; }

    // Debug output.
    auto showState(Node const& ls, std::vector<std::string> const& names) const -> std::string;
    auto showStates(std::vector<std::string> const& names) const -> std::string;

  private:
    CFG const* _grammar;                         // Grammar.
    Generator<std::optional<Token>>* _generator; // Token stream.

    std::deque<Token> _sentence;                          // Parsed tokens.
    std::deque<std::deque<Node>> _forest;                 // The DP array, aka. "shared packed parse forest (SPPF)".
    std::unordered_map<State, Node*, State::Hasher> _map; // Map for state deduplication.
    std::unordered_multimap<std::pair<size_t, Symbol>, Node*, PairHasher>
      _completions; // Map of nonempty completion candidates.

    // Returns next non-ignored token, or `std::nullopt` if reaches EOF.
    auto _nextToken() -> std::optional<Token> {
      while (!_generator->eof()) {
        auto const token = _generator->advance();
        if (token && token->id != _grammar->ignoredSymbol) return token;
      }
      return std::nullopt;
    }

    // Adds a state `s` to `_forest` while registering it in `_map`.
    // If state is already added, returns a pointer to it.
    auto _add(size_t pos, State s) -> Node* {
      assert_always(pos == s.endPos);
      if (auto const it = _map.find(s); it != _map.end()) {
        assert_always(it->second->state == s);
        return it->second;
      }
      _forest[pos].push_back(Node{s, {}});
      return _map[s] = &_forest[pos].back();
    }

    // The parsing algorithm.
    auto _run() -> bool;
    // auto _lastError(size_t startPos, size_t endPos, std::optional<Symbol> const& got) const -> ParserError;
  };

}

#endif // PARSER_HPP_
