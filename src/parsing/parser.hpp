// Parsing :: Grammar, GrammarBuilder, Node, Parser...

#ifndef PARSER_HPP_
#define PARSER_HPP_

#include <deque>
#include <limits>
#include <optional>
#include <unordered_map>
#include <variant>
#include <common.hpp>
#include "generator.hpp"
#include "lexer.hpp"

namespace Parsing {

  // Preprocessed context-free grammar for use by `Parser`.
  struct Grammar {
    struct Rule {
      std::pair<Symbol, Precedence> lhs;
      std::vector<std::pair<Symbol, Precedence>> rhs;
    };
    Symbol numSymbols;                            // Number of symbols = (Maximum symbol ID occured in rules) + 1.
    Symbol startSymbol;                           // Starting symbol ID.
    Symbol ignoredSymbol;                         // Ignored symbol ID.
    std::vector<Rule> rules;                      // Rule ID -> (LHS symbol, RHS symbols).
    std::vector<std::optional<size_t>> emptyRule; // LHS symbol ID -> empty rule ID.
    std::vector<size_t> sorted;                   // Indices of non-empty rules, sorted by LHS symbol.
    std::vector<size_t> firstRule;                // LHS symbol ID -> index in `sorted`.
  };

  // Grammar preprocessor.
  class GrammarBuilder {
  public:
    auto withStartSymbol(Symbol value) -> GrammarBuilder&;
    auto withIgnoredSymbol(Symbol value) -> GrammarBuilder&;
    auto withRule(std::pair<Symbol, Precedence> lhs, std::vector<std::pair<Symbol, Precedence>> const& rhs)
      -> GrammarBuilder&;

    // Constructs a well-formed `Grammar`.
    auto make() -> Grammar const;

  private:
    Symbol _startSymbol = 0;
    Symbol _ignoredSymbol = 0;
    std::vector<Grammar::Rule> _rules;
  };

  // An Earley state emitted by a parser.
  // All pointers should be non-empty and valid.
  struct Node {
    struct State {
      size_t startPos; // Start index in sentence.
      size_t endPos;   // End index in sentence.
      size_t rule;     // Production rule ID.
      size_t progress; // Index in production rule.
      // Required since `State`s are used as keys to `std::unordered_map`.
      auto operator==(State const&) const -> bool = default;
      // Required since `State`s are used as keys to `std::unordered_map`.
      struct Hasher {
        auto operator()(State const& s) const -> size_t {
          return hash_combine(hash_combine(hash_combine(s.startPos, s.endPos), s.rule), s.progress);
        }
      };
    };
    struct Link {
      Node const* prev;                              // Link to the previous state ("go left").
      std::variant<Node const*, Token const*> child; // Link to the child state or token ("go down").
    };
    State state;             // Payload.
    std::vector<Link> links; // Backward links.
  };

  /*
  // Error generated by parser.
  struct ParserError {
    size_t startPos;
    size_t endPos;
    std::vector<Symbol> expected;
    std::optional<Symbol> got;
  };
  */

  // Earley parser!
  // This is more suitable for left-recursive grammars than right-recursive ones.
  class Parser {
  public:
    // Given references must be valid over the `Parser`'s lifetime.
    Parser(Grammar const& grammar, Generator<std::optional<Token>>& generator):
      _grammar(grammar),
      _generator(generator) {}

    auto eof() const -> bool { return _generator.eof(); }
    auto advance() -> bool;

    // Retrieves results.
    auto sentence() const -> std::deque<Token> const& { return _sentence; }
    auto forest() const -> std::deque<std::deque<Node>> const& { return _forest; }

    // Debug output.
    auto showState(Node const& ls, std::vector<std::string> const& names) const -> std::string;
    auto showStates(std::vector<std::string> const& names) const -> std::string;

  private:
    Grammar const& _grammar;                     // Grammar.
    Generator<std::optional<Token>>& _generator; // Token stream.
    std::deque<Token> _sentence;                 // Parsed tokens.
    std::deque<std::deque<Node>> _forest;        // The DP array, aka. "shared packed parse forest (SPPF)".
    // Map for state deduplication.
    std::unordered_map<Node::State, Node*, Node::State::Hasher> _map;
    // Map of nonempty completion candidates.
    std::unordered_multimap<std::pair<size_t, Symbol>, Node*, PairHasher> _completions;

    auto _nextToken() -> std::optional<Token>;
    auto _add(size_t pos, Node::State s) -> Node*;
    auto _run() -> bool;
  };

}

#endif // PARSER_HPP_
