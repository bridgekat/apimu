/*
--------------------------------------------------------------------------------
这个文件包含来自于策梅洛-弗兰克尔（Zermelo-Fraenkel）集合论的定义和公理（加上选择公理）。
虽然是用形式化的语法写成的，但它实际上是非形式化的（即，没有经过计算机验证）！

2021.12.17
--------------------------------------------------------------------------------
*/


#推理引擎 局部 搜索_简易算法 理论下可满足性_z5 神经网络_gpt10f 神经网络_阿尔法证明_零 神经网络_小镇做题家引擎
// 启动一些我从未来下载的推理引擎


任取谓词 属于/2 {
  #中缀记号 ∈ 属于

  任取 x y 定义 不属于 := (并非 x ∈ y);
  #中缀记号 ∉ 不属于

  任取 x y 定义 被包括于 := (对所有 z ∈ x, z ∈ y);
  #中缀记号 ⊆ 被包括于

  // 我们可以通过写 “对所有 a ∈ x, ...” 来表示 “对所有 a, a ∈ x 意味着 ...”
  //     或者通过写 “存在着 a ∈ x, ...” 来表示 “存在着 a, a ∈ x 且 ...”
  // 所有一元和二元谓词都可以这样简写。

  // 一条公理...
  假设 (对所有 x y, (对所有 a, a ∈ x 当且仅当 a ∈ y) 意味着 x = y)
  记为 集合的外延性
      "外延性公理"
      "两个集合相等，当且仅当它们有相同的元素" {

    // 一条公理...
    假设 (对所有 x, (存在着 a ∈ x) 意味着 (存在着 y ∈ x, 并非 存在着 a, a ∈ x 且 a ∈ y))
    记为 集合的正则性
        "正则性公理"
        "基础公理"
        "每个非空集合x都至少包含一个元素y使得y和x不相交" {

      // 一条公理模式...
      假设 (对所有谓词 φ/2, 对所有 x, 存在着 y, 对所有 a, a ∈ y 当且仅当 a ∈ x 且 φ x a)
      记为 子集（原始版本）
          "子集公理模式（原始版本）"
          "指定公理模式（原始版本）"
          "分离公理模式（原始版本）"
          "给定一个集合，它的任意可描述子集都存在（原始版本）" {

        // 它的一个更常用的形式（证明了唯一性，这样我们就能用“确定描述”规则把它写成一个函数）
        任取谓词 φ/2 任取 x {
          任取 y1 假设 (对所有 a, a ∈ y1 当且仅当 (a ∈ x 且 φ x a)) {
            任取 y2 假设 (对所有 a, a ∈ y2 当且仅当 (a ∈ x 且 φ x a)) {
              => (对所有 z, z ∈ y1 当且仅当 z ∈ y2);
              => (y1 = y2) 根据 集合的外延性;
            }
          }
          => (唯一存在着 y, 对所有 a, a ∈ y 当且仅当 (a ∈ x 且 φ x a));

          定义 子集 :: (对所有 a, a ∈ 子集 当且仅当 (a ∈ x 且 φ x a))
          记为 子集的定义;
        }

        // 现在可以定义空集了（ApiMu假设论域非空）
        => (对所有 x, 唯一存在着 y, 对所有 a, a ∈ y 当且仅当 (a ∈ x 且 假));
        => (唯一存在着 x, 对所有 y, y ∉ x);

        定义 空集 :: (对所有 y, y ∉ 空集);
        记为 空集的定义
            "空集不包含任何元素";

        // 一条公理...
        假设 (对所有 x y, 存在着 z, x ∈ z 且 y ∈ z)
        记为 配对集（原始版本）
            "配对公理（原始版本）"
            "给定两个集合，存在一个集合包含它们两个作为元素（原始版本）" {

          // 它的一个更常用的形式（“恰好只有”x和y...）
          任取 x y {
            任取 z' 假设 (x ∈ z' 且 y ∈ z') {
              不公开 定义 z := 子集 (a | a = x 或 a = y) z'; // 用`子集`来删除x和y以外的所有元素
              => (存在着 z, 对所有 a, a ∈ z' 当且仅当 a = x 或 a = y);
            }
            => (存在着     z, 对所有 a, a ∈ z 当且仅当 a = x 或 a = y) 根据 存在着.使用规则;
            => (唯一存在着 z, 对所有 a, a ∈ z 当且仅当 a = x 或 a = y) 根据 集合的外延性;

            定义 配对集 :: (对所有 a, a ∈ 配对集 当且仅当 a = x 或 a = y)
            记为 配对集的定义
                "x和y的配对集恰好只包含x和y";
          }

          // 一个比较方便的定义
          任取 x {
            定义 单个集 := (配对集 x x);
            => (对所有 a, a ∈ 单个集 x 当且仅当 a = x 或 a = x);
            => (对所有 a, a ∈ 单个集 x 当且仅当 a = x) 记为 单个集的定义;
          }

          // 一条公理...
          假设 (对所有 F, 存在着 z, 对所有 x ∈ F, 对所有 a ∈ x, a ∈ z)
          记为 并集（原始版本）
              "并集公理（原始版本）"
              "给定一族集合，存在一个集合包括了这些集合的并集（原始版本）" {

            // 它的一个更常用的形式（“恰好是”想要的并集...）
            任取 F {
              任取 z' 假设 (对所有 x ∈ F, 对所有 a ∈ x, a ∈ z') {
                不公开 定义 z := 子集 (a | 存在着 x ∈ F, a ∈ x) z'; // 用`子集`来删除x的元素以外的所有元素
                任取 a {
                  假设 (a ∈ z) { => (存在着 x ∈ F, a ∈ x); }
                  假设 (存在着 x ∈ F, a ∈ x) { 任取 x 假设 (x ∈ F 且 a ∈ x) { => (a ∈ z'); } => (a ∈ z); }
                }
                => (存在着 z, 对所有 a, a ∈ z 当且仅当 (存在着 x ∈ F, a ∈ x));
              }
              => (存在着     z, 对所有 a, a ∈ z 当且仅当 (存在着 x ∈ F, a ∈ x)) 根据 存在着.使用规则;
              => (唯一存在着 z, 对所有 a, a ∈ z 当且仅当 (存在着 x ∈ F, a ∈ x)) 根据 集合的外延性;

              定义 并集 :: (对所有 a, a ∈ 并集 当且仅当 (存在着 x ∈ F, a ∈ x))
              记为 并集的定义
                  "一族集合的并集恰好包含了这些集合的元素";
            }

            // 一条公理模式...
            // 因为“确定描述”规则已经建立在了逻辑系统中，替换公理模式可以被等价地写成：
            假设 (对所有函数 φ/2, 对所有 x, 存在着 y, 对所有 a ∈ x, φ x a ∈ y)
            记为 像集（原始版本）
                "像集公理模式（原始版本）"
                "替换公理模式（原始版本）"
                "给定一个可描述的函数和它的定义域，存在一个集合是它的到达域（原始版本）" {

              // 它的一个更常用的形式（“恰好是”想要的像集...）
              任取函数 φ/2 任取 x {
                任取 y' 假设 (对所有 a ∈ x, φ x a ∈ y') {
                  不公开 定义 y := 子集 (b | 存在着 a ∈ x, b = φ x a) y'; // 用`子集`来删除...
                  任取 b {
                    假设 (b ∈ y) { => (存在着 a ∈ x, b = φ x a); }
                    假设 (存在着 a ∈ x, b = φ x a) { 任取 a 假设 (a ∈ x 且 b = φ x a) { => (b ∈ y'); } => (b ∈ y); }
                  }
                  => (对所有 b, b ∈ y 当且仅当 (存在着 a ∈ x, b = φ x a));
                  => (存在着 y, 对所有 b, b ∈ y 当且仅当 (存在着 a ∈ x, b = φ x a));
                }
                => (存在着     y, 对所有 b, b ∈ y 当且仅当 (存在着 a ∈ x, b = φ x a)) 根据 存在着.使用规则;
                => (唯一存在着 y, 对所有 b, b ∈ y 当且仅当 (存在着 a ∈ x, b = φ x a)) 根据 集合的外延性;

                定义 像集 :: (对所有 b, b ∈ 像集 当且仅当 (存在着 a ∈ x, b = φ x a))
                记为 像集的定义
                    "一个函数φ的像集恰好包含了通过对定义域x里的元素应用φ得到的那些元素";
              }

              // 一条公理...
              假设 (存在着 x, 空集 ∈ x 且 对所有 a ∈ x, (配对集 a (单个集 a)) ∈ x)
              记为 归纳集（原始版本）
                  "无穷公理（原始版本）"
                  "存在着一个无穷归纳集，可用于构造自然数集（原始版本）" {

                // 一条公理...
                假设 (对所有 x, 存在着 y, 对所有 z ⊆ x, z ∈ y)
                记为 幂集（原始版本）
                    "幂集公理（原始版本）"
                    "给定一个集合，存在一个集合包含了它的所有子集（原始版本）" {

                  // 它的一个更常用的形式（“恰好是”想要的幂集...）
                  任取 x {
                    任取 y' 假设 (对所有 z ⊆ x, z ∈ y') {
                      不公开 定义 y := 子集 (a | a ⊆ x) y';
                      => (存在着 y, 对所有 a, a ∈ y 当且仅当 a ⊆ x);
                    }
                    => (存在着     y, 对所有 a, a ∈ y 当且仅当 a ⊆ x) 根据 存在着.使用规则;
                    => (唯一存在着 y, 对所有 a, a ∈ y 当且仅当 a ⊆ x) 根据 集合的外延性;

                    定义 幂集 :: (对所有 a, a ∈ 幂集 当且仅当 a ⊆ x)
                    记为 幂集的定义
                        "一个集合x的幂集恰好包含了x的所有子集作为元素";
                  }

                  // 每当“选取”关键字被使用时，选择公理都会被调用（在元理论层面上！）。
                  // 同样，`选取`也足以在此证明选择公理：
                  任取 x 假设 (空集 ∉ x) 不公开 {
                    任取 y 假设 (y ∈ x) {
                      => (存在着 a ∈ y);
                      选取 f :: (f ∈ y) 记为 f的定义;
                      #列出 // f的定义 : (f ∈ y)
                    }
                    #列出 // f的定义 : (对所有 y ∈ x, f y ∈ y)
                    // To complete the remaining steps, one could take the Cartesian product of x and ∪x, and use `subset` to make f_fn...
                  }

                  // The elaborator has special support for several set-theoretic notations:
                  #解释器 +subset_builder_fn 子集 // (TODO: the notation {a ∈ x | φ a})
                  #解释器 +singletonset_builder_fn 单个集 // (TODO: the notation {x})
                  #解释器 +pairset_builder_fn 配对集 // (TODO: the notation {x, y} and {x})
                  #解释器 +listset_builder_fn singletonset pairset unionset // (TODO: the notations {a, b, c, d, e}, etc.)
                  #解释器 +binary_union_fn pairset unionset // (TODO: the notations (x ∪ y), etc.)


/*
--------------------------------------------------------------------------------
This is a non-closing theory (i.e. it adds primitive symbols and axioms when imported).
--------------------------------------------------------------------------------
*/

